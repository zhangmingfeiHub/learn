
一、队列
1、有消费者订阅/监听队列，消息到达队列后会被立即发送给订阅/监听该队列的消费者

2、没有消费者订阅/监听队列，消息会保存在队列中，等有消费者订阅/监听该队列，消息才会发送给订阅/监听的消费者

3、有多个消费者订阅/监听队列，消息分发给消费者有两种方式：
	3.1、轮询(round-robin)分发，每个消费者处理的消费者的机会是一样的，不论消费者处理速度快 或 慢
	3.2、公平分发(fair)，处理速度快点消费者会被多分发到消息，即谁有空谁就处理

4、设定消费者自动确认（即 auto_ack=true），如消息到达消费者（或说消费者接收到了消息），则rabbitMq会自动认为消费者确认了消息，
	则不论消费者是否处理成功，是否发生异常，rabbitMq会把消息从队列中删除
	
5、设定消费者非自动确认（即 auto_ack=false）：
	5.1、消费者接收到消息，未报异常，但没有显示调basicAck()方法向rabbitMq发送确认，
		则消息还在队列中，但属于unack状态（未确认状态），此时若：
		5.1.1、断开消费者，则队列中的消息由unack状态变为ready状态，可由新的消费者来消费
		5.1.2、再添加一个消费者C2，在unack状态的消息不会被推送给新的消费者C2，如果此时生产者发送新的消息给队列，rabbitMq还是会按规则分发给两个消费者，
			只是老的消费者C1不会发送确认，消息都变为unack状态了，新的消费者C2发送确认后，rabbitMq会把消息从队列中删除
	5.2、消费者接收到消息，报异常了，并调basicNack()方法向rabbitMq表示拒收该条消息，受该方法requeue参数影响，
		如设requeue=true表示拒收的消息重新入队列，入队列的消息（即ready状态的消息）又会由消费者消费处理，但报异常后又拒收，导致恶性循环了，
		如设requeue=false表示拒收的消息不再重新入队列，则rabbitMq会把消息从队列中删除
	5.3、消费者接收到消息，报异常了，但没有调basicNack()方法向rabbitMq表示拒收该消息，
		则消息还在队列，但状态为unack了，此时的情况又如5.1 所述了
		
6、不同种情况实践
	6.1、先队列中有消息，再连接多个消费者：
		6.1.1、队列先连接处理速度慢的消费者C1，再连接速度快的消费者C2，此时rabbitMq在等待C1处理，(经验证与消费者处理速度快慢无关);
			队列连接多个消费者C1 和 C2，两个消费者几乎同时连上队列，但还是C2先连接到队列，则rabbitMq会把消息从队列中推送给消费者C2，
			并队列中所有的消息的状态都为unack了，并最终队列中的消息都分发给C2来处理了，C1不会被分发到一条消息
	6.2、先连接多个消费者，再生产者往队列中发送消息：
		6.2.1、此时会按设定的规则来处理，即如果采取的轮询方式，则每个消费者都能处理一样多的消息，
			不论每个消费者处理的速度快慢，，只是处理快的消费者处理快

二、交换器
1、direct类型exchange，一个exchange一个queue可以通过多个routing-key绑定

2、exchange类型不同，推送消息到queue策略不同

3、一个queue可以由多个消费者监听