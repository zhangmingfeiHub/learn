
一、队列
1、有消费者订阅/监听队列，消息到达队列后会被立即发送给订阅/监听该队列的消费者

2、没有消费者订阅/监听队列，消息会保存在队列中，等有消费者订阅/监听该队列，消息才会发送给订阅/监听的消费者

3、有多个消费者订阅/监听队列，消息分发给消费者有两种方式：
	3.1、轮询(round-robin)分发，每个消费者处理的消费者的机会是一样的，不论消费者处理速度快 或 慢
	3.2、公平分发(fair)，处理速度快点消费者会被多分发到消息，即谁有空谁就处理

4、设定消费者自动确认（即 auto_ack=true），如消息到达消费者（或说消费者接收到了消息），则rabbitMq会自动认为消费者确认了消息，
	则不论消费者是否处理成功，是否发生异常，rabbitMq会把消息从队列中删除
	
5、设定消费者非自动确认（即 auto_ack=false）：
	5.1、消费者接收到消息，未报异常，但没有显示调basicAck()方法向rabbitMq发送确认，
		则消息还在队列中，但属于unack状态（未确认状态），此时若：
		5.1.1、断开消费者，则队列中的消息由unack状态变为ready状态，可由新的消费者来消费
		5.1.2、再添加一个消费者C2，在unack状态的消息不会被推送给新的消费者C2，如果此时生产者发送新的消息给队列，rabbitMq还是会按规则分发给两个消费者，
			只是老的消费者C1不会发送确认，消息都变为unack状态了，新的消费者C2发送确认后，rabbitMq会把消息从队列中删除
	5.2、消费者接收到消息，报异常了，并调basicNack()方法向rabbitMq表示拒收该条消息，受该方法requeue参数影响，
		如设requeue=true表示拒收的消息重新入队列，入队列的消息（即ready状态的消息）又会由消费者消费处理，但报异常后又拒收，导致恶性循环了，
		如设requeue=false表示拒收的消息不再重新入队列，则rabbitMq会把消息从队列中删除
	5.3、消费者接收到消息，报异常了，但没有调basicNack()方法向rabbitMq表示拒收该消息，
		则消息还在队列，但状态为unack了，此时的情况又如5.1 所述了，
		另一种表述：消费者发生异常，但没有调basicAck()方法确认，也没调basicNack()方法拒绝，rabbitMq会认为该消费者还没准备好接收下一条消息，
		不会再往该消费者分发消息了，也就是说后续分发给该消费者的消息，由于rabbitMq没有得到确认 或 拒绝，消息都为unack状态了
		
6、不同种情况实践
	6.1、先队列中有消息，再连接多个消费者：
		6.1.1、队列先连接处理速度慢的消费者C1，再连接速度快的消费者C2，此时rabbitMq在等待C1处理，(经验证与消费者处理速度快慢无关);
			队列连接多个消费者C1 和 C2，两个消费者几乎同时连上队列，但还是C2先连接到队列，则rabbitMq会把消息从队列中推送给消费者C2，
			并队列中所有的消息的状态都为unack了，并最终队列中的消息都分发给C2来处理了，C1不会被分发到一条消息
	6.2、先连接多个消费者，再生产者往队列中发送消息：
		6.2.1、此时会按设定的规则来处理，即如果采取的轮询方式，则每个消费者都能处理一样多的消息，
			不论每个消费者处理的速度快慢，，只是处理快的消费者处理快

7、队列属性解释
	7.1、exclusive，是否排他
		7.1.1、true表示私有，只有当前消费者才能消费该队列消息，其他消费者尝试连接该队列会报异常
		7.1.2、当前消费者与该队列断开后（不再订阅/监听），该队列会被rabbitMq自动删除
	7.2、autoDelete，当没有消费者订阅/监听时，是否自动删除
		7.2.1、true表示当没有消费者订阅/监听时，自动删除
	7.3、需要建一个临时队列只为一个消费者服务，则可以结合exclusive 和 autoDelete一起使用，消费者断开，则队列自动删除
	7.4、声明一个已经存在的队列
		7.4.1、只有设定的参数完全匹配，rabbitMq就不会做处理，并返回成功，让人感觉队列已经创建成功一样
		7.4.2、如果设定的参数不匹配，声明队列会失败，会报异常
	7.5、queueDeclarePassive(queue_name)方法声明一个队列，可用来测试一个队列是否存在
		7.5.1、如果队列存在，则成功连接到指定队列
		7.5.2、如果队列不存在，则不会去创建一个队列，而是返回一个错误，会报异常

8、声明队列时，队列会自动绑定到默认的交换器，并把队列名作为路由键

二、交换器
1、direct类型exchange，一个exchange一个queue可以通过多个routing-key绑定

2、exchange类型不同，推送消息到queue策略不同

3、一个queue可以由多个消费者监听

4、如交换器exchange没有队列绑定，则生产者发送的消息会丢失，exchange不存储消息，只是根据规则路由给绑定的队列，队列会存储消息

三、持久化的问题
1、交换器exchange和队列queue默认是非持久化的，当rabbitMq服务器重启后，非持久化的队列 和 交换机 以及队列里的消息都没了

2、durable=true


